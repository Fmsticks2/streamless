"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Account = void 0;
const tslib_1 = require("tslib");
const Xbqcrypto_1 = require("../../utils/Xbqcrypto");
const keyAndAddresses_1 = require("../../utils/keyAndAddresses");
const ed = tslib_1.__importStar(require("@noble/ed25519"));
const BaseClient_1 = require("../BaseClient");
const OperationTypes_1 = require("../../interfaces/OperationTypes");
const bytes_1 = require("../../utils/bytes");
const JsonRpcMethods_1 = require("../../interfaces/JsonRpcMethods");
const retryExecuteFunction_1 = require("../../utils/retryExecuteFunction");
function getOperationBufferToSign(chainId, bytesPublicKey, bytesCompact) {
    // Chain id is an 64-bit unsigned integer, convert to byte array (big endian)
    const chainIdBuffer = new ArrayBuffer(8);
    const view = new DataView(chainIdBuffer);
    view.setBigUint64(0, chainId, false);
    return Buffer.concat([
        Buffer.from(chainIdBuffer),
        bytesPublicKey,
        bytesCompact,
    ]);
}
class Web3Account extends BaseClient_1.BaseClient {
    account;
    publicApiClient;
    chainId;
    constructor(account, publicApiClient, chainId) {
        super(publicApiClient.clientConfig);
        this.account = account;
        this.publicApiClient = publicApiClient;
        this.chainId = chainId;
    }
    /**
     * Executes a blockchain operation
     *
     * @param txData - The transaction data for the operation.
     * @param operationType - The type of operation to be executed.
     * @param useRetry - Determines whether to use retry logic in case of failures.
     * @param errorMessage - Custom error message to throw if operation fails.
     * @param preExecutionCallback - An optional callback function to be executed before the operation, for any pre-execution logic or validation.
     * @returns Returns a promise that resolves to the operation ID.
     */
    async executeOperation(txData, operationType, useRetry = false, errorMessage = 'Operation did not return a valid response', preExecutionCallback) {
        // Run pre-execution logic if provided
        if (preExecutionCallback) {
            await preExecutionCallback(txData);
        }
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        const bytesCompact = this.compactBytesForOperation(txData, operationType, expiryPeriod);
        const signature = await this.sign(getOperationBufferToSign(this.chainId, (0, bytes_1.getBytesPublicKey)(this.account.publicKey), bytesCompact));
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        let opIds;
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS;
        if (useRetry) {
            opIds = await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [
                jsonRpcRequestMethod,
                [[data]],
            ]);
        }
        else {
            opIds = await this.sendJsonRPCRequest(jsonRpcRequestMethod, [[data]]);
        }
        if (opIds.length <= 0)
            throw new Error(errorMessage);
        return opIds[0];
    }
    async verify() {
        // Create the secret key object
        const secretKeyBase58Encoded = this.account.secretKey;
        const secretKey = new keyAndAddresses_1.SecretKey(secretKeyBase58Encoded);
        // create the public key object
        const publicKey = await secretKey.getPublicKey();
        if (this.account.publicKey &&
            this.account.publicKey !== publicKey.base58Encode) {
            throw new Error('Public key does not correspond the the private key submitted');
        }
        // get wallet account address
        const address = keyAndAddresses_1.Address.fromPublicKey(publicKey);
        if (this.account.address && this.account.address !== address.base58Encode) {
            throw new Error('Account address not correspond the the address submitted');
        }
    }
    async sign(data) {
        // check private keys to sign the message with.
        if (!this.account.secretKey) {
            throw new Error('No private key to sign the message with');
        }
        // check public key to verify the message with.
        if (!this.account.publicKey) {
            throw new Error('No public key to verify the signed message with');
        }
        if (data instanceof Uint8Array) {
            data = Buffer.from(data);
        }
        if (typeof data === 'string') {
            data = Buffer.from(data, 'utf-8');
        }
        // get private key
        const secretKey = new keyAndAddresses_1.SecretKey(this.account.secretKey);
        // bytes compaction
        const bytesCompact = Buffer.from(data);
        // Hash byte compact
        const messageHashDigest = (0, Xbqcrypto_1.hashBlake3)(bytesCompact);
        // sign the digest
        const sig = await secretKey.signDigest(messageHashDigest);
        // check sig length
        if (sig.length != 64) {
            throw new Error(`Invalid signature length. Expected 64, got ${sig.length}`);
        }
        // verify signature
        if (this.account.publicKey) {
            const publicKey = await secretKey.getPublicKey();
            const isVerified = await ed.verify(sig, messageHashDigest, publicKey.bytes);
            if (!isVerified) {
                throw new Error(`Signature could not be verified with public key. Please inspect`);
            }
        }
        // convert signature to base58
        const version = Buffer.from((0, Xbqcrypto_1.varintEncode)(secretKey.version));
        const base58Encoded = (0, Xbqcrypto_1.base58Encode)(Buffer.concat([version, sig]));
        return {
            publicKey: this.account.publicKey,
            base58Encoded: base58Encoded,
        };
    }
    address() {
        return this.account.address;
    }
    async sellRolls(txData) {
        return this.executeOperation(txData, OperationTypes_1.OperationTypeId.RollSell);
    }
    async buyRolls(txData) {
        return this.executeOperation(txData, OperationTypes_1.OperationTypeId.RollBuy);
    }
    async sendTransaction(txData) {
        return this.executeOperation(txData, OperationTypes_1.OperationTypeId.Transaction);
    }
    async callSmartContract(callData) {
        return this.executeOperation(callData, OperationTypes_1.OperationTypeId.CallSC, this.clientConfig.retryStrategyOn, 'Call smart contract operation bad response. No results array in json rpc response. Inspect smart contract');
    }
    async deploySmartContract(contractData) {
        const preExecutionLogic = async (data) => {
            // Check if SC data exists
            if (!data.contractDataBinary) {
                throw new Error('Expected non-null contract bytecode, but received null.');
            }
            // Get the block size
            const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
            if (data.contractDataBinary.length >
                nodeStatusInfo.config.max_block_size / 2) {
                console.warn('Bytecode size exceeded half of the maximum size of a block, operation will certainly be rejected');
            }
        };
        return this.executeOperation(contractData, OperationTypes_1.OperationTypeId.ExecuteSC, false, 'Deploy smart contract operation bad response. No results array in json rpc response. Inspect smart contract', preExecutionLogic);
    }
}
exports.Web3Account = Web3Account;
//# sourceMappingURL=Web3Account.js.map