"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Address = exports.PublicKey = exports.SecretKey = void 0;
const tslib_1 = require("tslib");
const Xbqcrypto_1 = require("./Xbqcrypto");
const ed = tslib_1.__importStar(require("@noble/ed25519"));
const bytes_1 = require("./bytes");
const web3_utils_1 = require("@massalabs/web3-utils");
/**
 * A secret key.
 * The secret key object is created from a base58 encoded string representing the secret key.
 *
 * @remarks
 * - String representation is S + base58Check(version_bytes + secret_key_hash_bytes)
 * - bytes attribute is the Uint8Array representation of the secret key.
 */
class SecretKey {
    version;
    bytes;
    constructor(secretKeyBase58Encoded) {
        const versionAndKeyBytes = (0, bytes_1.getBytesSecretKey)(secretKeyBase58Encoded);
        const { value, bytes } = (0, Xbqcrypto_1.varintDecode)(versionAndKeyBytes);
        this.version = value;
        this.bytes = versionAndKeyBytes.slice(bytes);
    }
    /* Get the public key from the secret key */
    async getPublicKey() {
        const publicKeyArray = await ed.getPublicKey(this.bytes);
        return new PublicKey(publicKeyArray, this.version);
    }
    /* Sign a message hash digest with the secret key */
    async signDigest(messageHashDigest) {
        return await ed.sign(messageHashDigest, this.bytes);
    }
}
exports.SecretKey = SecretKey;
/**
 * The PublicKey class represents a cryptographic public key.
 *
 * @remarks
 * - The public key is derived from the secret key and got the same version as the secret key.
 * - String representation is P + base58Check(version_bytes + public_key_hash_bytes)
 * - bytes attribute is the Uint8Array representation of the public key.
 */
class PublicKey {
    version;
    base58Encode;
    bytes;
    constructor(bytes, version) {
        this.version = version;
        this.bytes = bytes;
        const versionBuffer = Buffer.from((0, Xbqcrypto_1.varintEncode)(this.version));
        // Generate base58 encoded public key
        this.base58Encode =
            web3_utils_1.PUBLIC_KEY_PREFIX +
                (0, Xbqcrypto_1.base58Encode)(Buffer.concat([versionBuffer, Buffer.from(this.bytes)]));
    }
    // Create a new PublicKey object from a base58 encoded string
    static fromString(base58Encoded) {
        const versionAndKeyBytes = (0, bytes_1.getBytesPublicKey)(base58Encoded);
        // Slice off the version byte
        const { value, bytes } = (0, Xbqcrypto_1.varintDecode)(versionAndKeyBytes);
        const keyBytes = versionAndKeyBytes.slice(bytes);
        return new PublicKey(keyBytes, value);
    }
}
exports.PublicKey = PublicKey;
/**
 * An address.
 *
 * @remarks when the address is created from a public key it got the same version as the public key.
 *
 * @remarks
 * - String representation is A + U/S + base58Check(version_bytes + hashBlake3(version_bytes + public_key_bytes))
 * - The address bytes representation is `version + hashBlake3(version + publicKey)`.
 * - bytes is not an attribute of the address object because it is not needed.
 */
class Address {
    base58Encode;
    version;
    prefix;
    versionBytesLength;
    versionAndAddressBytes;
    constructor(base58Encoded) {
        this.base58Encode = base58Encoded;
        this.setPrefix();
        this.setDecodedVersionAndAddressBytes();
        this.setVersion();
        const addressBytes = this.versionAndAddressBytes.slice(this.versionBytesLength);
        if (addressBytes.length !== 32) {
            throw new Error(`Expected address to be 32 bytes long not ${addressBytes.length}`);
        }
    }
    setPrefix() {
        this.prefix = this.base58Encode.slice(0, web3_utils_1.ADDRESS_PREFIX_LENGTH);
        if (![web3_utils_1.ADDRESS_USER_PREFIX, web3_utils_1.ADDRESS_CONTRACT_PREFIX].includes(this.prefix)) {
            throw new Error(`Invalid address prefix: ${this.prefix}`);
        }
    }
    setDecodedVersionAndAddressBytes() {
        const versionAndAddress = this.base58Encode.slice(web3_utils_1.ADDRESS_PREFIX_LENGTH);
        this.versionAndAddressBytes = new Uint8Array((0, Xbqcrypto_1.base58Decode)(versionAndAddress));
    }
    setVersion() {
        const { value, bytes: versionBytesLength } = (0, Xbqcrypto_1.varintDecode)(this.versionAndAddressBytes);
        this.version = value;
        this.versionBytesLength = versionBytesLength;
    }
    static fromPublicKey(publicKey) {
        const versionBuffer = Buffer.from((0, Xbqcrypto_1.varintEncode)(publicKey.version));
        const versionAndPublicKey = Buffer.concat([versionBuffer, publicKey.bytes]);
        // Generate base58 encoded address
        const base58Encoded = web3_utils_1.ADDRESS_USER_PREFIX +
            (0, Xbqcrypto_1.base58Encode)(Buffer.concat([versionBuffer, (0, Xbqcrypto_1.hashBlake3)(versionAndPublicKey)]));
        return new Address(base58Encoded);
    }
    get versionNumber() {
        return this.version;
    }
}
exports.Address = Address;
//# sourceMappingURL=keyAndAddresses.js.map