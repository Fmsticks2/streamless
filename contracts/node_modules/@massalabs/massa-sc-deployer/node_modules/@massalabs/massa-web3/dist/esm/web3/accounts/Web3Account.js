import { base58Encode, hashBlake3, varintEncode } from '../../utils/Xbqcrypto';
import { Address, SecretKey } from '../../utils/keyAndAddresses';
import * as ed from '@noble/ed25519';
import { BaseClient } from '../BaseClient';
import { OperationTypeId } from '../../interfaces/OperationTypes';
import { getBytesPublicKey } from '../../utils/bytes';
import { JSON_RPC_REQUEST_METHOD } from '../../interfaces/JsonRpcMethods';
import { trySafeExecute } from '../../utils/retryExecuteFunction';
function getOperationBufferToSign(chainId, bytesPublicKey, bytesCompact) {
    // Chain id is an 64-bit unsigned integer, convert to byte array (big endian)
    const chainIdBuffer = new ArrayBuffer(8);
    const view = new DataView(chainIdBuffer);
    view.setBigUint64(0, chainId, false);
    return Buffer.concat([
        Buffer.from(chainIdBuffer),
        bytesPublicKey,
        bytesCompact,
    ]);
}
export class Web3Account extends BaseClient {
    account;
    publicApiClient;
    chainId;
    constructor(account, publicApiClient, chainId) {
        super(publicApiClient.clientConfig);
        this.account = account;
        this.publicApiClient = publicApiClient;
        this.chainId = chainId;
    }
    /**
     * Executes a blockchain operation
     *
     * @param txData - The transaction data for the operation.
     * @param operationType - The type of operation to be executed.
     * @param useRetry - Determines whether to use retry logic in case of failures.
     * @param errorMessage - Custom error message to throw if operation fails.
     * @param preExecutionCallback - An optional callback function to be executed before the operation, for any pre-execution logic or validation.
     * @returns Returns a promise that resolves to the operation ID.
     */
    async executeOperation(txData, operationType, useRetry = false, errorMessage = 'Operation did not return a valid response', preExecutionCallback) {
        // Run pre-execution logic if provided
        if (preExecutionCallback) {
            await preExecutionCallback(txData);
        }
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        const bytesCompact = this.compactBytesForOperation(txData, operationType, expiryPeriod);
        const signature = await this.sign(getOperationBufferToSign(this.chainId, getBytesPublicKey(this.account.publicKey), bytesCompact));
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        let opIds;
        const jsonRpcRequestMethod = JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS;
        if (useRetry) {
            opIds = await trySafeExecute(this.sendJsonRPCRequest, [
                jsonRpcRequestMethod,
                [[data]],
            ]);
        }
        else {
            opIds = await this.sendJsonRPCRequest(jsonRpcRequestMethod, [[data]]);
        }
        if (opIds.length <= 0)
            throw new Error(errorMessage);
        return opIds[0];
    }
    async verify() {
        // Create the secret key object
        const secretKeyBase58Encoded = this.account.secretKey;
        const secretKey = new SecretKey(secretKeyBase58Encoded);
        // create the public key object
        const publicKey = await secretKey.getPublicKey();
        if (this.account.publicKey &&
            this.account.publicKey !== publicKey.base58Encode) {
            throw new Error('Public key does not correspond the the private key submitted');
        }
        // get wallet account address
        const address = Address.fromPublicKey(publicKey);
        if (this.account.address && this.account.address !== address.base58Encode) {
            throw new Error('Account address not correspond the the address submitted');
        }
    }
    async sign(data) {
        // check private keys to sign the message with.
        if (!this.account.secretKey) {
            throw new Error('No private key to sign the message with');
        }
        // check public key to verify the message with.
        if (!this.account.publicKey) {
            throw new Error('No public key to verify the signed message with');
        }
        if (data instanceof Uint8Array) {
            data = Buffer.from(data);
        }
        if (typeof data === 'string') {
            data = Buffer.from(data, 'utf-8');
        }
        // get private key
        const secretKey = new SecretKey(this.account.secretKey);
        // bytes compaction
        const bytesCompact = Buffer.from(data);
        // Hash byte compact
        const messageHashDigest = hashBlake3(bytesCompact);
        // sign the digest
        const sig = await secretKey.signDigest(messageHashDigest);
        // check sig length
        if (sig.length != 64) {
            throw new Error(`Invalid signature length. Expected 64, got ${sig.length}`);
        }
        // verify signature
        if (this.account.publicKey) {
            const publicKey = await secretKey.getPublicKey();
            const isVerified = await ed.verify(sig, messageHashDigest, publicKey.bytes);
            if (!isVerified) {
                throw new Error(`Signature could not be verified with public key. Please inspect`);
            }
        }
        // convert signature to base58
        const version = Buffer.from(varintEncode(secretKey.version));
        const base58Encoded = base58Encode(Buffer.concat([version, sig]));
        return {
            publicKey: this.account.publicKey,
            base58Encoded: base58Encoded,
        };
    }
    address() {
        return this.account.address;
    }
    async sellRolls(txData) {
        return this.executeOperation(txData, OperationTypeId.RollSell);
    }
    async buyRolls(txData) {
        return this.executeOperation(txData, OperationTypeId.RollBuy);
    }
    async sendTransaction(txData) {
        return this.executeOperation(txData, OperationTypeId.Transaction);
    }
    async callSmartContract(callData) {
        return this.executeOperation(callData, OperationTypeId.CallSC, this.clientConfig.retryStrategyOn, 'Call smart contract operation bad response. No results array in json rpc response. Inspect smart contract');
    }
    async deploySmartContract(contractData) {
        const preExecutionLogic = async (data) => {
            // Check if SC data exists
            if (!data.contractDataBinary) {
                throw new Error('Expected non-null contract bytecode, but received null.');
            }
            // Get the block size
            const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
            if (data.contractDataBinary.length >
                nodeStatusInfo.config.max_block_size / 2) {
                console.warn('Bytecode size exceeded half of the maximum size of a block, operation will certainly be rejected');
            }
        };
        return this.executeOperation(contractData, OperationTypeId.ExecuteSC, false, 'Deploy smart contract operation bad response. No results array in json rpc response. Inspect smart contract', preExecutionLogic);
    }
}
//# sourceMappingURL=Web3Account.js.map