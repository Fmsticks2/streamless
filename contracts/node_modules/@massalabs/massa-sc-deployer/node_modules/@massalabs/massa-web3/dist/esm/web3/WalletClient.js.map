{"version":3,"file":"WalletClient.js","sourceRoot":"","sources":["../../../src/web3/WalletClient.ts"],"names":[],"mappings":"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","sourcesContent":["import { IClientConfig } from '../interfaces/IClientConfig';\nimport { IAccount } from '../interfaces/IAccount';\nimport { BaseClient } from './BaseClient';\nimport { IAddressInfo } from '../interfaces/IAddressInfo';\nimport { IFullAddressInfo } from '../interfaces/IFullAddressInfo';\nimport { ISignature } from '../interfaces/ISignature';\nimport {\n  base58Decode,\n  base58Encode,\n  varintEncode,\n  hashBlake3,\n} from '../utils/Xbqcrypto';\nimport { JSON_RPC_REQUEST_METHOD } from '../interfaces/JsonRpcMethods';\nimport { trySafeExecute } from '../utils/retryExecuteFunction';\nimport { ITransactionData } from '../interfaces/ITransactionData';\nimport { PublicApiClient } from './PublicApiClient';\nimport { IRollsData } from '../interfaces/IRollsData';\nimport { IBalance } from '../interfaces/IBalance';\nimport * as ed from '@noble/ed25519';\nimport { IWalletClient } from '../interfaces/IWalletClient';\nimport { Address, SecretKey, PublicKey } from '../utils/keyAndAddresses';\nimport { IBaseAccount } from '../interfaces/IBaseAccount';\nimport { Web3Account } from './accounts/Web3Account';\nimport {\n  KEYS_VERSION_NUMBER,\n  SECRET_KEY_PREFIX,\n  fromMAS,\n} from '@massalabs/web3-utils';\n\nconst MAX_WALLET_ACCOUNTS = 256;\n\n/**\n * A client class for interacting with wallets, which can seamlessly work with WebExtensions.\n *\n * @remarks\n * The WalletClient manages multiple accounts and handles operations such as transaction signing,\n * fetching account information, and interacting with the blockchain. It extends the BaseClient\n * class and implements the IWalletClient interface.\n */\nexport class WalletClient extends BaseClient implements IWalletClient {\n  private wallet: Array<IAccount> = [];\n  private baseAccount?: IBaseAccount;\n\n  /**\n   * Constructor of the {@link WalletClient} class.\n   *\n   * @param clientConfig - Configuration parameters for the client.\n   * @param publicApiClient - A {@link PublicApiClient} instance used for making API calls.\n   * @param baseAccount - (Optional) An {@link IAccount} to set as the base account for the wallet.\n   */\n  public constructor(\n    clientConfig: IClientConfig,\n    private readonly publicApiClient: PublicApiClient,\n    baseAccount?: IBaseAccount,\n  ) {\n    super(clientConfig);\n    if (baseAccount) {\n      this.baseAccount = baseAccount;\n    }\n\n    // ========== bind wallet methods ========= //\n\n    // wallet methods\n    this.cleanWallet = this.cleanWallet.bind(this);\n    this.getWalletAccounts = this.getWalletAccounts.bind(this);\n    this.getWalletAccountByAddress = this.getWalletAccountByAddress.bind(this);\n    this.addSecretKeysToWallet = this.addSecretKeysToWallet.bind(this);\n    this.addAccountsToWallet = this.addAccountsToWallet.bind(this);\n    this.removeAddressesFromWallet = this.removeAddressesFromWallet.bind(this);\n    this.walletInfo = this.walletInfo.bind(this);\n    this.signMessage = this.signMessage.bind(this);\n    this.getWalletAddressesInfo = this.getWalletAddressesInfo.bind(this);\n    this.setBaseAccount = this.setBaseAccount.bind(this);\n    this.getBaseAccount = this.getBaseAccount.bind(this);\n    this.sendTransaction = this.sendTransaction.bind(this);\n    this.sellRolls = this.sellRolls.bind(this);\n    this.buyRolls = this.buyRolls.bind(this);\n    this.getAccountBalance = this.getAccountBalance.bind(this);\n  }\n\n  /**\n   * Sets a provided account as the default (base) account for the wallet.\n   *\n   * @param baseAccount - An {@link IAccount} to be set as the base account.\n   *\n   * @returns A Promise that resolves to `void` when the base account has been set successfully.\n   */\n  public async setBaseAccount(baseAccount: IBaseAccount): Promise<void> {\n    if (!baseAccount.address()) {\n      throw new Error('Invalid base account address');\n    }\n    await baseAccount.verify();\n    this.baseAccount = baseAccount;\n  }\n\n  /**\n   * Retrieves the default (base) account of the wallet.\n   *\n   * @returns The default {@link IAccount} of the wallet. If no default account is set, it returns `null`.\n   */\n  public getBaseAccount(): IBaseAccount | null {\n    return this.baseAccount;\n  }\n\n  /**\n   * Retrieves all accounts stored in the wallet.\n   *\n   * @returns An array of {@link IAccount} objects.\n   */\n  public getWalletAccounts(): Array<IAccount> {\n    return this.wallet;\n  }\n\n  /**\n   * Removes all accounts from the wallet.\n   */\n  public cleanWallet(): void {\n    this.wallet.length = 0;\n    this.baseAccount = null;\n  }\n\n  /**\n   * Retrieves a wallet account based on its address.\n   *\n   * @param address - The address of the account to retrieve.\n   *\n   * @returns The {@link IAccount} associated with the provided address\n   * or `undefined` if no account with the given address is found in the wallet.\n   */\n  public getWalletAccountByAddress(address: string): IAccount | undefined {\n    return this.wallet.find(\n      (w) => w.address.toLowerCase() === address.toLowerCase(),\n    ); // ignore case for flexibility\n  }\n\n  /**\n   * Adds a set of private keys to the wallet.\n   *\n   * @param secretKeys - An array of base58 encoded private keys to be added to the wallet.\n   *\n   * @throws if the number of private keys exceeds the maximum limit.\n   *\n   * @returns A Promise that resolves to an array of {@link IAccount} objects.\n   */\n  public async addSecretKeysToWallet(\n    secretKeys: Array<string>,\n  ): Promise<Array<IAccount>> {\n    if (secretKeys.length > MAX_WALLET_ACCOUNTS) {\n      throw new Error(\n        `Maximum number of allowed wallet accounts exceeded ${MAX_WALLET_ACCOUNTS}. Submitted private keys: ${secretKeys.length}`,\n      );\n    }\n    const accountsToCreate: IAccount[] = [];\n\n    const uniqueSecretKeys = secretKeys.filter(\n      (value, index, self) => self.indexOf(value) === index,\n    );\n\n    for (const secretKeyBase58Encoded of uniqueSecretKeys) {\n      const secretKey = new SecretKey(secretKeyBase58Encoded);\n      const publicKey: PublicKey = await secretKey.getPublicKey();\n      const address: Address = Address.fromPublicKey(publicKey);\n\n      if (!this.getWalletAccountByAddress(address.base58Encode)) {\n        accountsToCreate.push({\n          secretKey: secretKeyBase58Encoded,\n          publicKey: publicKey.base58Encode,\n          address: address.base58Encode,\n        } as IAccount);\n      }\n    }\n\n    this.wallet.push(...accountsToCreate);\n    return accountsToCreate;\n  }\n\n  /**\n   * Adds a set of accounts to the wallet.\n   *\n   * @privateRemarks\n   * Each account must have a base58 encoded random entropy or private key.\n   *\n   * @param accounts - An array of accounts ({@link IAccount} objects) to be added to the wallet.\n   *\n   * @throws\n   * - If the number of accounts exceeds the {@link MAX_WALLET_ACCOUNTS} limit\n   * - If an account is missing a private key\n   * - If a submitted public key doesn't correspond to the associated private key\n   * - If an account address doesn't correspond to the private key-derived address\n   *\n   * @returns A Promise that resolves to an array of {@link IAccount} objects.\n   */\n  public async addAccountsToWallet(\n    accounts: Array<IAccount>,\n  ): Promise<Array<IAccount>> {\n    if (accounts.length > MAX_WALLET_ACCOUNTS) {\n      throw new Error(\n        `Maximum number of allowed wallet accounts exceeded ${MAX_WALLET_ACCOUNTS}. Submitted accounts: ${accounts.length}`,\n      );\n    }\n    const accountsAdded: Array<IAccount> = [];\n\n    for (const account of accounts) {\n      if (!account.secretKey) {\n        throw new Error('Missing account private key');\n      }\n\n      // Create the secret key object\n      const secretKeyBase58Encoded: string = account.secretKey;\n      const secretKey: SecretKey = new SecretKey(secretKeyBase58Encoded);\n\n      // create the public key object\n      const publicKey: PublicKey = await secretKey.getPublicKey();\n      if (account.publicKey && account.publicKey !== publicKey.base58Encode) {\n        throw new Error(\n          'Public key does not correspond the the private key submitted',\n        );\n      }\n\n      // get wallet account address\n      const address: Address = Address.fromPublicKey(publicKey);\n      if (account.address && account.address !== address.base58Encode) {\n        throw new Error(\n          'Account address not correspond the the address submitted',\n        );\n      }\n\n      if (!this.getWalletAccountByAddress(address.base58Encode)) {\n        accountsAdded.push({\n          address: address.base58Encode,\n          secretKey: secretKeyBase58Encoded,\n          publicKey: publicKey.base58Encode,\n        } as IAccount);\n      }\n    }\n\n    this.wallet.push(...accountsAdded);\n    return accountsAdded;\n  }\n\n  /**\n   * Remove a list of addresses from the wallet.\n   *\n   * @param addresses - An array of addresses to remove from the wallet.\n   */\n  public removeAddressesFromWallet(addresses: Array<string>): void {\n    for (const address of addresses) {\n      const index = this.wallet.findIndex((w) => w.address === address);\n      if (index > -1) {\n        this.wallet.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Retrieves detailed information about the wallet.\n   *\n   * @throws Will throw an error if the number of retrieved wallets does not match the number of addresses in the wallet.\n   *\n   * @returns A Promise that resolves to an array of {@link IFullAddressInfo} objects.\n   */\n  public async walletInfo(): Promise<Array<IFullAddressInfo>> {\n    if (this.wallet.length === 0) {\n      return [];\n    }\n    const addresses: Array<string> = this.wallet.map(\n      (account) => account.address,\n    );\n    const addressesInfo: Array<IAddressInfo> =\n      await this.getWalletAddressesInfo(addresses);\n\n    if (addressesInfo.length !== this.wallet.length) {\n      throw new Error(\n        `Requested wallets not fully retrieved. Got ${addressesInfo.length}, expected: ${this.wallet.length}`,\n      );\n    }\n\n    return addressesInfo.map((info, index) => {\n      return {\n        publicKey: this.wallet[index].publicKey,\n        secretKey: this.wallet[index].secretKey,\n        ...info,\n      } as IFullAddressInfo;\n    });\n  }\n\n  /**\n   * Generates a new wallet account.\n   * @param KEYS_VERSION_NUMBER - The version number of the secret key to be generated, to create a new account.\n   *\n   * @returns A Promise that resolves to an {@link IAccount} object, which represents the newly created account.\n   */\n  public static async walletGenerateNewAccount(): Promise<IAccount> {\n    // generate private key\n    const secretKeyArray: Uint8Array = ed.utils.randomPrivateKey();\n\n    const version = Buffer.from(varintEncode(KEYS_VERSION_NUMBER));\n    const secretKeyBase58Encoded: string =\n      SECRET_KEY_PREFIX +\n      base58Encode(Buffer.concat([version, secretKeyArray]));\n    const secretKey: SecretKey = new SecretKey(secretKeyBase58Encoded);\n\n    // get public key\n    const publicKey: PublicKey = await secretKey.getPublicKey();\n\n    // get wallet account address\n    const address: Address = Address.fromPublicKey(publicKey);\n\n    return {\n      address: address.base58Encode,\n      secretKey: secretKeyBase58Encoded,\n      publicKey: publicKey.base58Encode,\n    } as IAccount;\n  }\n\n  /**\n   * Generates an account from a given private key.\n   *\n   * @param secretKeyBase58 - A base58 encoded private key from which the account will be generated.\n   *\n   * @returns A Promise that resolves to an {@link IAccount} object.\n   */\n  public static async getAccountFromSecretKey(\n    secretKeyBase58: string,\n  ): Promise<IAccount> {\n    // get private key\n    const secretKey: SecretKey = new SecretKey(secretKeyBase58);\n    // get public key\n    const publicKey: PublicKey = await secretKey.getPublicKey();\n\n    // get wallet account address\n    const address: Address = Address.fromPublicKey(publicKey);\n\n    return {\n      address: address.base58Encode,\n      secretKey: secretKeyBase58,\n      publicKey: publicKey.base58Encode,\n    } as IAccount;\n  }\n\n  /**\n   * Signs a random message data using a wallet account that has already been added.\n   *\n   * @param data - The data to be signed.\n   * @param accountSignerAddress - The address of the wallet account that will sign the data.\n   *\n   * @throws Will throw an error if the account associated with the provided address is not found in the wallet.\n   *\n   * @returns A Promise that resolves to an {@link ISignature} object representing the signature.\n   */\n  public async signMessage(\n    data: string | Buffer,\n    chainId: bigint,\n    accountSignerAddress: string,\n  ): Promise<ISignature> {\n    let signerAccount = this.getWalletAccountByAddress(accountSignerAddress);\n    let account: IBaseAccount;\n    if (!signerAccount) {\n      if (this.baseAccount.address() === accountSignerAddress) {\n        account = this.baseAccount;\n      } else {\n        throw new Error(\n          `No signer account ${accountSignerAddress} found in wallet`,\n        );\n      }\n    } else {\n      account = new Web3Account(signerAccount, this.publicApiClient, chainId);\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data);\n    }\n    return account.sign(data);\n  }\n\n  /**\n   * Retrieves information about specified wallet addresses.\n   *\n   * @param addresses - An array of wallet addresses for which information is to be retrieved.\n   *\n   * @returns A Promise that resolves to an array of {@link IAddressInfo} objects, each containing\n   * information about a corresponding wallet address.\n   */\n  private async getWalletAddressesInfo(\n    addresses: Array<string>,\n  ): Promise<Array<IAddressInfo>> {\n    const jsonRpcRequestMethod = JSON_RPC_REQUEST_METHOD.GET_ADDRESSES;\n    if (this.clientConfig.retryStrategyOn) {\n      return await trySafeExecute<Array<IAddressInfo>>(\n        this.sendJsonRPCRequest,\n        [jsonRpcRequestMethod, [addresses]],\n      );\n    } else {\n      return await this.sendJsonRPCRequest<Array<IAddressInfo>>(\n        jsonRpcRequestMethod,\n        [addresses],\n      );\n    }\n  }\n\n  /**\n   * Signs the provided data with the given address.\n   *\n   * @remarks\n   * The address must be present in the wallet.\n   *\n   * @param data - The data to be signed.\n   * @param signer - The account that will be used to sign the data.\n   *\n   * @throws\n   * - if no private key is available for signing the message.\n   * - if no public key is available for verifying the signed message.\n   * - if the length of the generated signature is not valid.\n   * - if the signature could not be verified with the public key.\n   *\n   * @returns A Promise that resolves to an {@link ISignature} object representing the signature.\n   */\n  public static async walletSignMessage(\n    data: string | Buffer,\n    signer: IBaseAccount,\n  ): Promise<ISignature> {\n    return signer.sign(Buffer.from(data));\n  }\n\n  /**\n   * Verify a signature.\n   *\n   * @param data - The signed data to verify.\n   * @param signature - The signature to verify.\n   * @param signerPubKey - The public key of the signer.\n   *\n   * @returns A Promise that resolves to `true` if the signature is valid, `false` otherwise.\n   */\n  public async verifySignature(\n    data: string | Buffer,\n    signature: ISignature,\n  ): Promise<boolean> {\n    // setup the public key.\n    const publicKey: PublicKey = PublicKey.fromString(signature.publicKey);\n\n    // setup the message digest.\n    const bytesCompact: Buffer = Buffer.from(data);\n    const messageDigest: Uint8Array = hashBlake3(bytesCompact);\n\n    try {\n      // setup the signature.\n      const versionAndSignatureBytes: Buffer = base58Decode(\n        signature.base58Encoded,\n      );\n\n      // removing the version byte\n      const signatureBytes: Uint8Array = versionAndSignatureBytes.slice(1);\n      // check sig length\n      if (signatureBytes.length != 64) {\n        throw new Error(\n          `Invalid signature length. Expected 64, got ${signatureBytes.length}`,\n        );\n      }\n      if (publicKey.bytes.length != 32) {\n        throw new Error(\n          `Invalid public key length. Expected 32, got ${publicKey.bytes.length}`,\n        );\n      }\n      // verify signature.\n      const isVerified = await ed.verify(\n        signatureBytes,\n        messageDigest,\n        publicKey.bytes,\n      );\n      return isVerified;\n    } catch (err) {\n      console.error('Failed to verify signature:', err);\n      return false;\n    }\n  }\n\n  /**\n   * Retrieves the balance of an account.\n   *\n   * @param address - The address to get the balance from.\n   *\n   * @returns A Promise that resolves to an {@link IBalance}. If the address is not found,\n   * it returns `null`.\n   */\n  public async getAccountBalance(address: string): Promise<IBalance | null> {\n    try {\n      const addresses: Array<IAddressInfo> =\n        await this.publicApiClient.getAddresses([address]);\n      if (addresses.length === 0) return null;\n\n      const addressInfo: IAddressInfo = addresses.at(0);\n      return {\n        candidate: fromMAS(addressInfo.candidate_balance),\n        final: fromMAS(addressInfo.final_balance),\n      } as IBalance;\n    } catch (err) {\n      console.error('Failed to get account balance:', err);\n      return null;\n    }\n  }\n\n  /**\n   * Sends native MAS from a wallet address to another.\n   *\n   * @param txData - The transaction data.\n   * @param executor - (Optional) The account that will execute the transaction. If not\n   * provided, the base account is used.\n   *\n   * @throws if no sender account is available for the transaction.\n   *\n   * @returns a promise that resolves to an array of operations ids.\n   */\n  public async sendTransaction(\n    txData: ITransactionData,\n    executor?: IBaseAccount,\n  ): Promise<Array<string>> {\n    // check sender account\n    const sender: IBaseAccount = executor || this.getBaseAccount();\n    if (!sender) {\n      throw new Error('No tx sender available');\n    }\n    return [await sender.sendTransaction(txData)];\n  }\n\n  /**\n   * Buy rolls with wallet address.\n   *\n   * @param txData - The transaction data\n   * @param executor - (Optional) The account that will execute the transaction.\n   * If not specified, the base account is used by default.\n   *\n   * @throws if no sender account is available for the transaction.\n   *\n   * @returns a promise that resolves to an array of operations ids.\n   */\n  public async buyRolls(\n    txData: IRollsData,\n    executor?: IBaseAccount,\n  ): Promise<Array<string>> {\n    // check sender account\n    const sender: IBaseAccount = executor || this.getBaseAccount();\n    if (!sender) {\n      throw new Error('No tx sender available');\n    }\n    return [await sender.buyRolls(txData)];\n  }\n\n  /**\n   * Sell rolls with wallet address.\n   *\n   * @param txData - The transaction data.\n   * @param executor - (Optional) The account that will execute the transaction.\n   * If not specified, the base account is used by default.\n   *\n   * @throws if no sender account is available for the transaction.\n   *\n   * @returns a promise that resolves to an array of operations ids.\n   */\n  public async sellRolls(\n    txData: IRollsData,\n    executor?: IBaseAccount,\n  ): Promise<Array<string>> {\n    // check sender account\n    const sender: IBaseAccount = executor || this.getBaseAccount();\n    if (!sender) {\n      throw new Error('No tx sender available');\n    }\n    return [await sender.sellRolls(txData)];\n  }\n}\n"]}