{"version":3,"file":"keyAndAddresses.js","sourceRoot":"","sources":["../../../src/utils/keyAndAddresses.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  base58Encode,\n  varintEncode,\n  varintDecode,\n  hashBlake3,\n  base58Decode,\n} from './Xbqcrypto';\n\nimport * as ed from '@noble/ed25519';\nimport { getBytesPublicKey, getBytesSecretKey } from './bytes';\nimport {\n  ADDRESS_CONTRACT_PREFIX,\n  ADDRESS_PREFIX_LENGTH,\n  ADDRESS_USER_PREFIX,\n  PUBLIC_KEY_PREFIX,\n} from '@massalabs/web3-utils';\n\n/**\n * A secret key.\n * The secret key object is created from a base58 encoded string representing the secret key.\n *\n * @remarks\n * - String representation is S + base58Check(version_bytes + secret_key_hash_bytes)\n * - bytes attribute is the Uint8Array representation of the secret key.\n */\nexport class SecretKey {\n  version: number;\n  bytes: Uint8Array;\n\n  constructor(secretKeyBase58Encoded: string) {\n    const versionAndKeyBytes = getBytesSecretKey(secretKeyBase58Encoded);\n    const { value, bytes } = varintDecode(versionAndKeyBytes);\n    this.version = value;\n    this.bytes = versionAndKeyBytes.slice(bytes);\n  }\n\n  /* Get the public key from the secret key */\n  async getPublicKey(): Promise<PublicKey> {\n    const publicKeyArray: Uint8Array = await ed.getPublicKey(this.bytes);\n    return new PublicKey(publicKeyArray, this.version);\n  }\n\n  /* Sign a message hash digest with the secret key */\n  async signDigest(messageHashDigest: Uint8Array): Promise<Uint8Array> {\n    return await ed.sign(messageHashDigest, this.bytes);\n  }\n}\n\n/**\n * The PublicKey class represents a cryptographic public key.\n *\n * @remarks\n * - The public key is derived from the secret key and got the same version as the secret key.\n * - String representation is P + base58Check(version_bytes + public_key_hash_bytes)\n * - bytes attribute is the Uint8Array representation of the public key.\n */\nexport class PublicKey {\n  version: number;\n  base58Encode: string;\n  bytes: Uint8Array;\n\n  constructor(bytes: Uint8Array, version: number) {\n    this.version = version;\n    this.bytes = bytes;\n    const versionBuffer = Buffer.from(varintEncode(this.version));\n\n    // Generate base58 encoded public key\n    this.base58Encode =\n      PUBLIC_KEY_PREFIX +\n      base58Encode(Buffer.concat([versionBuffer, Buffer.from(this.bytes)]));\n  }\n\n  // Create a new PublicKey object from a base58 encoded string\n  static fromString(base58Encoded: string): PublicKey {\n    const versionAndKeyBytes = getBytesPublicKey(base58Encoded);\n\n    // Slice off the version byte\n    const { value, bytes } = varintDecode(versionAndKeyBytes);\n    const keyBytes = versionAndKeyBytes.slice(bytes);\n\n    return new PublicKey(keyBytes, value);\n  }\n}\n\n/**\n * An address.\n *\n * @remarks when the address is created from a public key it got the same version as the public key.\n *\n * @remarks\n * - String representation is A + U/S + base58Check(version_bytes + hashBlake3(version_bytes + public_key_bytes))\n * - The address bytes representation is `version + hashBlake3(version + publicKey)`.\n * - bytes is not an attribute of the address object because it is not needed.\n */\nexport class Address {\n  base58Encode: string;\n  private version: number;\n  private prefix: string;\n  private versionBytesLength: number;\n  private versionAndAddressBytes: Uint8Array;\n\n  constructor(base58Encoded: string) {\n    this.base58Encode = base58Encoded;\n    this.setPrefix();\n    this.setDecodedVersionAndAddressBytes();\n    this.setVersion();\n\n    const addressBytes = this.versionAndAddressBytes.slice(\n      this.versionBytesLength,\n    );\n\n    if (addressBytes.length !== 32) {\n      throw new Error(\n        `Expected address to be 32 bytes long not ${addressBytes.length}`,\n      );\n    }\n  }\n\n  private setPrefix(): void {\n    this.prefix = this.base58Encode.slice(0, ADDRESS_PREFIX_LENGTH);\n    if (![ADDRESS_USER_PREFIX, ADDRESS_CONTRACT_PREFIX].includes(this.prefix)) {\n      throw new Error(`Invalid address prefix: ${this.prefix}`);\n    }\n  }\n\n  private setDecodedVersionAndAddressBytes(): void {\n    const versionAndAddress = this.base58Encode.slice(ADDRESS_PREFIX_LENGTH);\n    this.versionAndAddressBytes = new Uint8Array(\n      base58Decode(versionAndAddress),\n    );\n  }\n\n  private setVersion(): void {\n    const { value, bytes: versionBytesLength } = varintDecode(\n      this.versionAndAddressBytes,\n    );\n    this.version = value;\n    this.versionBytesLength = versionBytesLength;\n  }\n\n  static fromPublicKey(publicKey: PublicKey): Address {\n    const versionBuffer = Buffer.from(varintEncode(publicKey.version));\n    const versionAndPublicKey = Buffer.concat([versionBuffer, publicKey.bytes]);\n\n    // Generate base58 encoded address\n    const base58Encoded =\n      ADDRESS_USER_PREFIX +\n      base58Encode(\n        Buffer.concat([versionBuffer, hashBlake3(versionAndPublicKey)]),\n      );\n\n    return new Address(base58Encoded);\n  }\n\n  get versionNumber(): number {\n    return this.version;\n  }\n}\n"]}