{"version":3,"file":"bytes.js","sourceRoot":"","sources":["../../../src/utils/bytes.ts"],"names":[],"mappings":";;;AAAA,2CAA2C;AAE3C;;;GAGG;AACH,MAAM,iBAAiB,GAAG,GAAG,CAAC;AAC9B,MAAM,iBAAiB,GAAG,GAAG,CAAC;AAC9B,MAAM,wBAAwB,GAAG,CAAC,CAAC;AACnC,MAAM,wBAAwB,GAAG,CAAC,CAAC;AAEnC;;;;;;;;GAQG;AACH,SAAgB,iBAAiB,CAAC,SAAiB;IACjD,MAAM,MAAM,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,wBAAwB,CAAC,CAAC;IAE5D,IAAI,CAAC,CAAC,MAAM,IAAI,iBAAiB,CAAC,EAAE;QAClC,MAAM,IAAI,KAAK,CACb,+BAA+B,MAAM,wCAAwC,iBAAiB,iDAAiD,CAChJ,CAAC;KACH;IACD,MAAM,sBAAsB,GAAW,IAAA,wBAAY,EACjD,SAAS,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAC1C,CAAC;IACF,OAAO,sBAAsB,CAAC;AAChC,CAAC;AAZD,8CAYC;AAED;;;;;;;;GAQG;AACH,SAAgB,iBAAiB,CAAC,SAAiB;IACjD,MAAM,MAAM,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,wBAAwB,CAAC,CAAC;IAE5D,IAAI,CAAC,CAAC,MAAM,IAAI,iBAAiB,CAAC,EAAE;QAClC,MAAM,IAAI,KAAK,CACb,8BAA8B,MAAM,cAAc,iBAAiB,EAAE,CACtE,CAAC;KACH;IACD,MAAM,sBAAsB,GAAW,IAAA,wBAAY,EACjD,SAAS,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAC1C,CAAC;IACF,OAAO,sBAAsB,CAAC;AAChC,CAAC;AAZD,8CAYC","sourcesContent":["import { base58Decode } from './Xbqcrypto';\n\n/**\n * Prefixes for secret and public keys.\n * Prefixes are used as a convention to differentiate one key from another.\n */\nconst SECRET_KEY_PREFIX = 'S';\nconst PUBLIC_KEY_PREFIX = 'P';\nconst SECRET_KEY_PREFIX_LENGTH = 1;\nconst PUBLIC_KEY_PREFIX_LENGTH = 1;\n\n/**\n * Get the byte representation of a given secret key.\n *\n * @param secretKey - The secret key to get the bytes from.\n *\n * @throws if the secret key is not valid.\n *\n * @returns a Uint8Array containing the bytes of the secret key.\n */\nexport function getBytesSecretKey(secretKey: string): Uint8Array {\n  const prefix = secretKey.slice(0, SECRET_KEY_PREFIX_LENGTH);\n\n  if (!(prefix == SECRET_KEY_PREFIX)) {\n    throw new Error(\n      `Invalid secret key prefix: \"${prefix}\". The secret key should start with \"${SECRET_KEY_PREFIX}\". Please verify your secret key and try again.`,\n    );\n  }\n  const secretKeyBase58Decoded: Buffer = base58Decode(\n    secretKey.slice(SECRET_KEY_PREFIX_LENGTH),\n  );\n  return secretKeyBase58Decoded;\n}\n\n/**\n * Retrieves the byte representation of a given public key.\n *\n * @param publicKey - The public key to obtain the bytes from.\n *\n * @throws If the public key has an incorrect {@link PUBLIC_KEY_PREFIX}.\n *\n * @returns A Uint8Array containing the bytes of the public key.\n */\nexport function getBytesPublicKey(publicKey: string): Uint8Array {\n  const prefix = publicKey.slice(0, PUBLIC_KEY_PREFIX_LENGTH);\n\n  if (!(prefix == PUBLIC_KEY_PREFIX)) {\n    throw new Error(\n      `Invalid public key prefix: ${prefix} should be ${PUBLIC_KEY_PREFIX}`,\n    );\n  }\n  const publicKeyBase58Decoded: Buffer = base58Decode(\n    publicKey.slice(PUBLIC_KEY_PREFIX_LENGTH), // Slice off the prefix\n  );\n  return publicKeyBase58Decoded;\n}\n"]}