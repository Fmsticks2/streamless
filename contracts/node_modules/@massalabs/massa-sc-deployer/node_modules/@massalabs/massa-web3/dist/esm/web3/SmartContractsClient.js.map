{"version":3,"file":"SmartContractsClient.js","sourceRoot":"","sources":["../../../src/web3/SmartContractsClient.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This file includes the implementation for the {@link SmartContractsClient} class. This class provides methods for interacting with smart contracts\n * in the Massa blockchain. Such methods include {@link SmartContractsClient#deploySmartContract|deploying}, {@link SmartContractsClient#callSmartContract|calling},\n * and {@link SmartContractsClient#readSmartContract|reading} smart contracts, as well as retrieving smart contract {@link SmartContractsClient#getFilteredScOutputEvents|events}\n * and {@link SmartContractsClient#getContractBalance|balances}.\n *\n * @module SmartContractsClient\n */\nimport { EOperationStatus } from '../interfaces/EOperationStatus';\nimport { IAddressInfo } from '../interfaces/IAddressInfo';\nimport { IBalance } from '../interfaces/IBalance';\nimport { ICallData } from '../interfaces/ICallData';\nimport { IClientConfig } from '../interfaces/IClientConfig';\nimport { IContractData } from '../interfaces/IContractData';\n\nimport { IEventFilter } from '../interfaces/IEventFilter';\nimport { IExecuteReadOnlyData } from '../interfaces/IExecuteReadOnlyData';\nimport { IExecuteReadOnlyResponse } from '../interfaces/IExecuteReadOnlyResponse';\nimport { IOperationData } from '../interfaces/IOperationData';\nimport { IReadData } from '../interfaces/IReadData';\nimport { ISmartContractsClient } from '../interfaces/ISmartContractsClient';\nimport { JSON_RPC_REQUEST_METHOD } from '../interfaces/JsonRpcMethods';\nimport { trySafeExecute } from '../utils/retryExecuteFunction';\nimport { BaseClient } from './BaseClient';\nimport { PublicApiClient } from './PublicApiClient';\nimport { IWalletClient } from '../interfaces/IWalletClient';\nimport { IBaseAccount } from '../interfaces/IBaseAccount';\nimport {\n  IContractReadOperationResponse,\n  IContractReadOperationData,\n  IEvent,\n  Args,\n  fromMAS,\n  MAX_GAS_CALL,\n} from '@massalabs/web3-utils';\nimport { wait } from '../utils/time';\n\nconst WAIT_STATUS_TIMEOUT = 60000;\nconst TX_POLL_INTERVAL_MS = 1000;\n\n/**\n * The key name (as a string) to look for when we are retrieving the proto file from a contract\n */\nexport const MASSA_PROTOFILE_KEY = 'protoMassa';\n/**\n * The separator used to split the proto file content into separate proto files\n */\nexport const PROTO_FILE_SEPARATOR = '|||||';\n/**\n * Smart Contracts Client object enables smart contract deployment, calls and streaming of events.\n */\nexport class SmartContractsClient\n  extends BaseClient\n  implements ISmartContractsClient\n{\n  /**\n   * Constructor for {@link SmartContractsClient} objects.\n   */\n  public constructor(\n    clientConfig: IClientConfig,\n    private readonly publicApiClient: PublicApiClient,\n    private readonly walletClient: IWalletClient,\n  ) {\n    super(clientConfig);\n\n    // bind class methods\n    this.deploySmartContract = this.deploySmartContract.bind(this);\n    this.getFilteredScOutputEvents = this.getFilteredScOutputEvents.bind(this);\n    this.executeReadOnlySmartContract =\n      this.executeReadOnlySmartContract.bind(this);\n    this.awaitRequiredOperationStatus =\n      this.awaitRequiredOperationStatus.bind(this);\n    this.getOperationStatus = this.getOperationStatus.bind(this);\n    this.callSmartContract = this.callSmartContract.bind(this);\n    this.readSmartContract = this.readSmartContract.bind(this);\n    this.getContractBalance = this.getContractBalance.bind(this);\n  }\n\n  /**\n   * Deploy a smart contract on the massa blockchain by creating and sending\n   * an operation containing byte code.\n   *\n   * @remarks\n   * If no executor is provided, the default wallet account from the provided {@link WalletClient}\n   * will be used.\n   *\n   * @param contractData - The deployment contract data.\n   * @param executor - The account to use for the deployment.\n   *\n   * @returns A promise that resolves to the operation ID of the deployment operation.\n   */\n  public async deploySmartContract(\n    contractData: IContractData,\n    executor?: IBaseAccount,\n  ): Promise<string> {\n    const sender = executor || this.walletClient.getBaseAccount();\n    if (!sender) {\n      throw new Error(`No tx sender available`);\n    }\n    return await sender.deploySmartContract(contractData);\n  }\n\n  /**\n   * Calls a smart contract method.\n   *\n   * @remarks\n   * If no executor is provided, the default wallet account will be used.\n   *\n   * @param callData -  The data required for the smart contract call.\n   * @param executor - The account that will execute the call (default: the default\n   * wallet account from {@link WalletClient}).\n   *\n   * @returns A promise that resolves to the operation ID of the call operation as a string.\n   */\n  public async callSmartContract(\n    callData: ICallData,\n    executor?: IBaseAccount,\n  ): Promise<string> {\n    const sender = executor || this.walletClient.getBaseAccount();\n    if (!sender) {\n      throw new Error(`No tx sender available`);\n    }\n    // check the max. allowed gas\n    if (callData.maxGas > MAX_GAS_CALL) {\n      throw new Error(\n        `The gas submitted ${callData.maxGas.toString()} exceeds the max. allowed block gas of ${MAX_GAS_CALL.toString()}`,\n      );\n    }\n\n    callData.coins = callData.coins || BigInt(0);\n\n    // check that the sender has enough balance to pay for coins\n    const senderBalance: IBalance = await this.walletClient.getAccountBalance(\n      sender.address(),\n    );\n    if (senderBalance.final < callData.coins) {\n      throw new Error(\n        `The sender ${sender.address()} does not have enough balance to pay for the coins`,\n      );\n    }\n    return await sender.callSmartContract(callData);\n  }\n\n  /**\n   * Execute a dry run Smart contract call and returns some data regarding its execution\n   * such as the changes of in the states that would have happen if the transaction was really executed on chain.\n   *\n   * @param readData - The data required for the a read operation of a smart contract.\n   *\n   * @returns A promise that resolves to an object which represents the result of the operation and contains data about its execution.\n   */\n  public async readSmartContract(\n    readData: IReadData,\n  ): Promise<IContractReadOperationResponse> {\n    // check the max. allowed gas\n    if (readData.maxGas > MAX_GAS_CALL) {\n      throw new Error(\n        `The gas submitted ${readData.maxGas.toString()} exceeds the max. allowed block gas of ${MAX_GAS_CALL.toString()}`,\n      );\n    }\n\n    if (readData.parameter instanceof Args)\n      readData.parameter = readData.parameter.serialize();\n\n    // request data\n    let baseAccountSignerAddress: string | null = null;\n    if (this.walletClient.getBaseAccount()) {\n      baseAccountSignerAddress = this.walletClient.getBaseAccount().address();\n    }\n    const data = {\n      max_gas: Number(readData.maxGas),\n      target_address: readData.targetAddress,\n      target_function: readData.targetFunction,\n      parameter: readData.parameter,\n      caller_address: readData.callerAddress || baseAccountSignerAddress,\n    };\n    // returns operation ids\n    const jsonRpcRequestMethod = JSON_RPC_REQUEST_METHOD.EXECUTE_READ_ONLY_CALL;\n    let jsonRpcCallResult: Array<IContractReadOperationData> = [];\n    if (this.clientConfig.retryStrategyOn) {\n      jsonRpcCallResult = await trySafeExecute<\n        Array<IContractReadOperationData>\n      >(this.sendJsonRPCRequest, [jsonRpcRequestMethod, [[data]]]);\n    } else {\n      jsonRpcCallResult = await this.sendJsonRPCRequest(jsonRpcRequestMethod, [\n        [data],\n      ]);\n    }\n\n    if (jsonRpcCallResult.length <= 0) {\n      throw new Error(\n        `Read operation bad response. No results array in json rpc response. Inspect smart contract`,\n      );\n    }\n    if (jsonRpcCallResult[0].result.Error) {\n      throw new Error(jsonRpcCallResult[0].result.Error);\n    }\n    return {\n      returnValue: new Uint8Array(jsonRpcCallResult[0].result.Ok),\n      info: jsonRpcCallResult[0],\n    };\n  }\n\n  /**\n   * Returns the balance of the smart contract.\n   *\n   * @param address - The address of the smart contract.\n   *\n   * @returns A promise that resolves to the balance of the smart contract.\n   */\n  public async getContractBalance(address: string): Promise<IBalance | null> {\n    const addresses: Array<IAddressInfo> =\n      await this.publicApiClient.getAddresses([address]);\n    if (addresses.length === 0) return null;\n    const addressInfo: IAddressInfo = addresses.at(0);\n    return {\n      candidate: fromMAS(addressInfo.candidate_balance),\n      final: fromMAS(addressInfo.final_balance),\n    } as IBalance;\n  }\n\n  /**\n   * Get filtered smart contract output events.\n   *\n   * @param eventFilterData - The filter data for the events.\n   *\n   * @returns A promise that resolves to an array of IEvent objects containing the filtered events.\n   */\n  public async getFilteredScOutputEvents(\n    eventFilterData: IEventFilter,\n  ): Promise<Array<IEvent>> {\n    const data = {\n      start: eventFilterData.start,\n      end: eventFilterData.end,\n      emitter_address: eventFilterData.emitter_address,\n      original_caller_address: eventFilterData.original_caller_address,\n      original_operation_id: eventFilterData.original_operation_id,\n      is_final: eventFilterData.is_final,\n    };\n\n    const jsonRpcRequestMethod =\n      JSON_RPC_REQUEST_METHOD.GET_FILTERED_SC_OUTPUT_EVENT;\n\n    // returns filtered events\n    if (this.clientConfig.retryStrategyOn) {\n      return await trySafeExecute<Array<IEvent>>(this.sendJsonRPCRequest, [\n        jsonRpcRequestMethod,\n        [data],\n      ]);\n    } else {\n      return await this.sendJsonRPCRequest<Array<IEvent>>(\n        jsonRpcRequestMethod,\n        [data],\n      );\n    }\n  }\n\n  /**\n   * Send a read-only smart contract execution request.\n   *\n   * @remarks\n   * This method is used to dry-run a smart contract execution and get the changes of the states that would\n   * have happen if the transaction was really executed on chain.\n   * This operation does not modify the blockchain state.\n   *\n   * @param contractData - The data required for the operation.\n   *\n   * @returns A promise which resolves to an object containing data about the operation.\n   *\n   * @throws\n   * - If the contract binary data is missing.\n   * - If the contract contract address is missing.\n   * - If the result is empty.\n   * - If the result contains an error.\n   */\n  public async executeReadOnlySmartContract(\n    contractData: IContractData,\n  ): Promise<IExecuteReadOnlyResponse> {\n    if (!contractData.contractDataBinary) {\n      throw new Error(\n        `Expected non-null contract bytecode, but received null.`,\n      );\n    }\n\n    if (!contractData.address) {\n      throw new Error(`Expected contract address, but received null.`);\n    }\n\n    const data = {\n      max_gas: Number(contractData.maxGas),\n      bytecode: Array.from(contractData.contractDataBinary),\n      address: contractData.address,\n    };\n\n    let jsonRpcCallResult: Array<IExecuteReadOnlyData> = [];\n    const jsonRpcRequestMethod =\n      JSON_RPC_REQUEST_METHOD.EXECUTE_READ_ONLY_BYTECODE;\n    if (this.clientConfig.retryStrategyOn) {\n      jsonRpcCallResult = await trySafeExecute<Array<IExecuteReadOnlyData>>(\n        this.sendJsonRPCRequest,\n        [jsonRpcRequestMethod, [[data]]],\n      );\n    } else {\n      jsonRpcCallResult = await this.sendJsonRPCRequest<\n        Array<IExecuteReadOnlyData>\n      >(jsonRpcRequestMethod, [[data]]);\n    }\n\n    if (jsonRpcCallResult.length <= 0) {\n      throw new Error(\n        `Read operation bad response. No results array in json rpc response. Inspect smart contract`,\n      );\n    }\n    if (jsonRpcCallResult[0].result.Error) {\n      throw new Error('Execute read-only smart contract error', {\n        cause: jsonRpcCallResult[0].result.Error,\n      });\n    }\n    return {\n      returnValue: new Uint8Array(jsonRpcCallResult[0].result.Ok),\n      info: jsonRpcCallResult[0],\n    };\n  }\n\n  /**\n   * Get the status of a specific operation.\n   *\n   * @param opId - The operation id.\n   *\n   * @returns A promise that resolves to the status of the operation.\n   */\n  public async getOperationStatus(opId: string): Promise<EOperationStatus> {\n    const operationData: Array<IOperationData> =\n      await this.publicApiClient.getOperations([opId]);\n\n    if (!operationData?.length) return EOperationStatus.NOT_FOUND;\n\n    const { is_operation_final, op_exec_status, in_pool, in_blocks } =\n      operationData[0];\n\n    if (is_operation_final === null && op_exec_status === null)\n      return EOperationStatus.UNEXECUTED_OR_EXPIRED;\n\n    if (in_pool) return EOperationStatus.AWAITING_INCLUSION;\n\n    if (is_operation_final) {\n      if (op_exec_status) return EOperationStatus.FINAL_SUCCESS;\n      // We explicitly check for false here because null means that the operation was not executed\n      if (op_exec_status === false) return EOperationStatus.FINAL_ERROR;\n    } else {\n      if (op_exec_status) return EOperationStatus.SPECULATIVE_SUCCESS;\n      if (op_exec_status === false) return EOperationStatus.SPECULATIVE_ERROR;\n    }\n\n    if (in_blocks.length > 0) return EOperationStatus.INCLUDED_PENDING;\n\n    return EOperationStatus.INCONSISTENT;\n  }\n\n  /**\n   * Get the status of a specific operation and wait until it reaches the required status.\n   *\n   * @param opId - The required operation id.\n   * @param requiredStatus - The required status.\n   *\n   * @returns A promise that resolves to the status of the operation.\n   */\n  public async awaitRequiredOperationStatus(\n    opId: string,\n    requiredStatus: EOperationStatus,\n    timeout?: number,\n  ): Promise<EOperationStatus> {\n    return await this.awaitOperationStatusHelper(\n      opId,\n      timeout,\n      (currentStatus) => currentStatus === requiredStatus,\n    );\n  }\n\n  /**\n   * Get the status of a specific operation and wait until it reaches one of the required statuses.\n   *\n   * @param opId - The required operation id.\n   * @param requiredStatuses - An array of required statuses.\n   *\n   * @returns A promise that resolves to the status of the operation.\n   */\n  public async awaitMultipleRequiredOperationStatus(\n    opId: string,\n    requiredStatuses: EOperationStatus[],\n    timeout?: number,\n  ): Promise<EOperationStatus> {\n    return await this.awaitOperationStatusHelper(\n      opId,\n      timeout,\n      (currentStatus) => requiredStatuses.includes(currentStatus),\n    );\n  }\n\n  /**\n   * Helper method to wait for a specific condition on an operation's status.\n   *\n   * @param opId - The operation id to check.\n   * @param statusCheck - A callback function that defines the condition for the operation status.\n   *\n   * @returns A promise that resolves to the status of the operation.\n   *\n   */\n  private async awaitOperationStatusHelper(\n    opId: string,\n    timeout = WAIT_STATUS_TIMEOUT,\n    statusCheck: (status: EOperationStatus) => boolean,\n  ): Promise<EOperationStatus> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      let currentStatus = EOperationStatus.NOT_FOUND;\n\n      try {\n        currentStatus = await this.getOperationStatus(opId);\n\n        if (statusCheck(currentStatus)) {\n          return currentStatus;\n        }\n      } catch (ex) {\n        console.warn(ex);\n      }\n      await wait(TX_POLL_INTERVAL_MS);\n    }\n\n    throw new Error(\n      `Failed to retrieve status of operation id: ${opId}: Timeout reached.`,\n    );\n  }\n}\n"]}