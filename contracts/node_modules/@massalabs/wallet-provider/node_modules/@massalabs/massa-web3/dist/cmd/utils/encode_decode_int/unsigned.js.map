{"version":3,"file":"unsigned.js","sourceRoot":"","sources":["../../../../src/utils/encode_decode_int/unsigned.ts"],"names":[],"mappings":";;;AAAA,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;AAE3B,MAAM,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACzB,MAAM,OAAO,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAC1B;;;;;GAKG;AAEH;;;;;GAKG;AACH,SAAgB,cAAc,CAAC,KAAa;IAC1C,IAAI,CAAC,GAAG,CAAC,CAAC;IAEV,OAAO,KAAK,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;QACjC,KAAK,KAAK,OAAO,CAAC;KACnB;IAED,OAAO,CAAC,GAAG,CAAC,CAAC;AACf,CAAC;AARD,wCAQC;AAED;;;;;;;GAOG;AACH,SAAgB,MAAM,CACpB,CAAS,EACT,MAAoB,EACpB,UAAmB;IAEnB,IAAI,CAAC,GAAG,MAAM,EAAE;QACd,MAAM,IAAI,UAAU,CAAC,wBAAwB,CAAC,CAAC;KAChD;IAED,MAAM,UAAU,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;IACrC,MAAM,GAAG,MAAM,IAAI,IAAI,WAAW,CAAC,UAAU,CAAC,CAAC;IAC/C,UAAU,GAAG,UAAU,IAAI,CAAC,CAAC;IAC7B,IAAI,MAAM,CAAC,UAAU,GAAG,UAAU,GAAG,UAAU,EAAE;QAC/C,MAAM,IAAI,UAAU,CAClB,4DAA4D,CAC7D,CAAC;KACH;IAED,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;IAEjD,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,OAAO,KAAK,GAAG,CAAC,EAAE;QAChB,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC;QAC3C,CAAC,KAAK,OAAO,CAAC;KACf;IAED,KAAK,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IAE1B,OAAO,KAAK,CAAC;AACf,CAAC;AA7BD,wBA6BC;AAED;;;;;;GAMG;AACH,SAAgB,MAAM,CAAC,IAAgB,EAAE,MAAM,GAAG,CAAC;IACjD,IAAI,CAAC,GAAG,MAAM,CAAC;IACf,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,IAAI,CAAS,CAAC;IACd,GAAG;QACD,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACrB,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,MAAM,IAAI,UAAU,CAAC,qBAAqB,CAAC,CAAC;SAC7C;QAED,CAAC,IAAI,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACvC,CAAC,EAAE,CAAC;KACL,QAAQ,IAAI,IAAI,CAAC,EAAE;IACpB,OAAO,CAAC,CAAC;AACX,CAAC;AAdD,wBAcC","sourcesContent":["const LIMIT = BigInt(0x7f);\n\nconst zeroBI = BigInt(0);\nconst sevenBI = BigInt(7);\n/**\n * @module unsigned.ts\n *\n * This module provides functions to encode and decode unsigned integers,\n * using Varint which is a more compact binary representation of them.\n */\n\n/**\n * Returns the number of bytes required to store the number in a varint.\n *\n * @param value - The number to encode.\n * @returns The number of bytes required to store the number.\n */\nexport function encodingLength(value: bigint): number {\n  let i = 0;\n\n  for (; value >= BigInt(0x80); i++) {\n    value >>= sevenBI;\n  }\n\n  return i + 1;\n}\n\n/**\n * Encodes a big number as a varint.\n *\n * @param i - The big number to encode.\n * @param buffer - The buffer to write the varint to (optional).\n * @param byteOffset - The offset in the buffer to start writing at (optional) (default: 0).\n * @returns The buffer that was written to.\n */\nexport function encode(\n  i: bigint,\n  buffer?: ArrayBuffer,\n  byteOffset?: number,\n): Uint8Array {\n  if (i < zeroBI) {\n    throw new RangeError('value must be unsigned');\n  }\n\n  const byteLength = encodingLength(i);\n  buffer = buffer || new ArrayBuffer(byteLength);\n  byteOffset = byteOffset || 0;\n  if (buffer.byteLength < byteOffset + byteLength) {\n    throw new RangeError(\n      'the buffer is too small to encode the number at the offset',\n    );\n  }\n\n  const array = new Uint8Array(buffer, byteOffset);\n\n  let offset = 0;\n  while (LIMIT < i) {\n    array[offset++] = Number(i & LIMIT) | 0x80;\n    i >>= sevenBI;\n  }\n\n  array[offset] = Number(i);\n\n  return array;\n}\n\n/**\n * Decodes a varint as a big number.\n *\n * @param data - The data to decode.\n * @param offset - The offset in the data to start reading at (optional) (default: 0).\n * @returns The decoded big number.\n */\nexport function decode(data: Uint8Array, offset = 0): bigint {\n  let i = zeroBI;\n  let n = 0;\n  let b: number;\n  do {\n    b = data[offset + n];\n    if (b === undefined) {\n      throw new RangeError('offset out of range');\n    }\n\n    i += BigInt(b & 0x7f) << BigInt(n * 7);\n    n++;\n  } while (0x80 <= b);\n  return i;\n}\n"]}