{"version":3,"file":"Web3Account.js","sourceRoot":"","sources":["../../../../src/web3/accounts/Web3Account.ts"],"names":[],"mappings":"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","sourcesContent":["import { IAccount } from '../../interfaces/IAccount';\nimport { IBaseAccount } from '../../interfaces/IBaseAccount';\nimport { INodeStatus } from '../../interfaces/INodeStatus';\nimport { IPublicApiClient } from '../../interfaces/IPublicApiClient';\nimport { IRollsData } from '../../interfaces/IRollsData';\nimport { ISignature } from '../../interfaces/ISignature';\nimport { base58Encode, hashBlake3, varintEncode } from '../../utils/Xbqcrypto';\nimport { Address, PublicKey, SecretKey } from '../../utils/keyAndAddresses';\nimport * as ed from '@noble/ed25519';\nimport { BaseClient } from '../BaseClient';\nimport { OperationTypeId } from '../../interfaces/OperationTypes';\nimport { getBytesPublicKey } from '../../utils/bytes';\nimport { JSON_RPC_REQUEST_METHOD } from '../../interfaces/JsonRpcMethods';\nimport { ICallData } from '../../interfaces/ICallData';\nimport { IContractData } from '../../interfaces/IContractData';\nimport { trySafeExecute } from '../../utils/retryExecuteFunction';\n\nfunction getOperationBufferToSign(\n  chainId: bigint,\n  bytesPublicKey: Uint8Array,\n  bytesCompact: Buffer,\n): Buffer {\n  // Chain id is an 64-bit unsigned integer, convert to byte array (big endian)\n  const chainIdBuffer = new ArrayBuffer(8);\n  const view = new DataView(chainIdBuffer);\n  view.setBigUint64(0, chainId, false);\n\n  return Buffer.concat([\n    Buffer.from(chainIdBuffer),\n    bytesPublicKey,\n    bytesCompact,\n  ]);\n}\n\nexport class Web3Account extends BaseClient implements IBaseAccount {\n  private account: IAccount;\n  private publicApiClient: IPublicApiClient;\n  private chainId: bigint;\n\n  constructor(\n    account: IAccount,\n    publicApiClient: IPublicApiClient,\n    chainId: bigint,\n  ) {\n    super(publicApiClient.clientConfig);\n    this.account = account;\n    this.publicApiClient = publicApiClient;\n    this.chainId = chainId;\n  }\n\n  /**\n   * Executes a blockchain operation\n   *\n   * @param txData - The transaction data for the operation.\n   * @param operationType - The type of operation to be executed.\n   * @param useRetry - Determines whether to use retry logic in case of failures.\n   * @param errorMessage - Custom error message to throw if operation fails.\n   * @param preExecutionCallback - An optional callback function to be executed before the operation, for any pre-execution logic or validation.\n   * @returns Returns a promise that resolves to the operation ID.\n   */\n  private async executeOperation(\n    txData: IRollsData | ICallData | IContractData,\n    operationType: OperationTypeId,\n    useRetry: boolean = false,\n    errorMessage: string = 'Operation did not return a valid response',\n    preExecutionCallback?: (\n      data: IRollsData | ICallData | IContractData,\n    ) => Promise<void>,\n  ): Promise<string> {\n    // Run pre-execution logic if provided\n    if (preExecutionCallback) {\n      await preExecutionCallback(txData);\n    }\n\n    const nodeStatusInfo: INodeStatus =\n      await this.publicApiClient.getNodeStatus();\n\n    const expiryPeriod: number =\n      nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;\n\n    const bytesCompact: Buffer = this.compactBytesForOperation(\n      txData,\n      operationType,\n      expiryPeriod,\n    );\n\n    const signature: ISignature = await this.sign(\n      getOperationBufferToSign(\n        this.chainId,\n        getBytesPublicKey(this.account.publicKey),\n        bytesCompact,\n      ),\n    );\n\n    const data = {\n      serialized_content: Array.prototype.slice.call(bytesCompact),\n      creator_public_key: this.account.publicKey,\n      signature: signature.base58Encoded,\n    };\n\n    let opIds: Array<string>;\n    const jsonRpcRequestMethod = JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS;\n\n    if (useRetry) {\n      opIds = await trySafeExecute<Array<string>>(this.sendJsonRPCRequest, [\n        jsonRpcRequestMethod,\n        [[data]],\n      ]);\n    } else {\n      opIds = await this.sendJsonRPCRequest(jsonRpcRequestMethod, [[data]]);\n    }\n\n    if (opIds.length <= 0) throw new Error(errorMessage);\n\n    return opIds[0];\n  }\n\n  public async verify(): Promise<void> {\n    // Create the secret key object\n    const secretKeyBase58Encoded: string = this.account.secretKey;\n    const secretKey: SecretKey = new SecretKey(secretKeyBase58Encoded);\n\n    // create the public key object\n    const publicKey: PublicKey = await secretKey.getPublicKey();\n    if (\n      this.account.publicKey &&\n      this.account.publicKey !== publicKey.base58Encode\n    ) {\n      throw new Error(\n        'Public key does not correspond the the private key submitted',\n      );\n    }\n\n    // get wallet account address\n    const address: Address = Address.fromPublicKey(publicKey);\n    if (this.account.address && this.account.address !== address.base58Encode) {\n      throw new Error(\n        'Account address not correspond the the address submitted',\n      );\n    }\n  }\n\n  public async sign(data: Buffer | Uint8Array | string): Promise<ISignature> {\n    // check private keys to sign the message with.\n    if (!this.account.secretKey) {\n      throw new Error('No private key to sign the message with');\n    }\n\n    // check public key to verify the message with.\n    if (!this.account.publicKey) {\n      throw new Error('No public key to verify the signed message with');\n    }\n\n    if (data instanceof Uint8Array) {\n      data = Buffer.from(data);\n    }\n    if (typeof data === 'string') {\n      data = Buffer.from(data, 'utf-8');\n    }\n\n    // get private key\n    const secretKey: SecretKey = new SecretKey(this.account.secretKey);\n\n    // bytes compaction\n    const bytesCompact: Buffer = Buffer.from(data);\n    // Hash byte compact\n    const messageHashDigest: Uint8Array = hashBlake3(bytesCompact);\n\n    // sign the digest\n    const sig = await secretKey.signDigest(messageHashDigest);\n\n    // check sig length\n    if (sig.length != 64) {\n      throw new Error(\n        `Invalid signature length. Expected 64, got ${sig.length}`,\n      );\n    }\n\n    // verify signature\n    if (this.account.publicKey) {\n      const publicKey: PublicKey = await secretKey.getPublicKey();\n\n      const isVerified = await ed.verify(\n        sig,\n        messageHashDigest,\n        publicKey.bytes,\n      );\n\n      if (!isVerified) {\n        throw new Error(\n          `Signature could not be verified with public key. Please inspect`,\n        );\n      }\n    }\n\n    // convert signature to base58\n    const version = Buffer.from(varintEncode(secretKey.version));\n    const base58Encoded = base58Encode(Buffer.concat([version, sig]));\n\n    return {\n      publicKey: this.account.publicKey,\n      base58Encoded: base58Encoded,\n    };\n  }\n\n  public address(): string {\n    return this.account.address;\n  }\n\n  public async sellRolls(txData: IRollsData): Promise<string> {\n    return this.executeOperation(txData, OperationTypeId.RollSell);\n  }\n  public async buyRolls(txData: IRollsData): Promise<string> {\n    return this.executeOperation(txData, OperationTypeId.RollBuy);\n  }\n\n  public async sendTransaction(txData: IRollsData): Promise<string> {\n    return this.executeOperation(txData, OperationTypeId.Transaction);\n  }\n\n  public async callSmartContract(callData: ICallData): Promise<string> {\n    return this.executeOperation(\n      callData,\n      OperationTypeId.CallSC,\n      this.clientConfig.retryStrategyOn,\n      'Call smart contract operation bad response. No results array in json rpc response. Inspect smart contract',\n    );\n  }\n\n  public async deploySmartContract(\n    contractData: IContractData,\n  ): Promise<string> {\n    const preExecutionLogic = async (data: IContractData) => {\n      // Check if SC data exists\n      if (!data.contractDataBinary) {\n        throw new Error(\n          'Expected non-null contract bytecode, but received null.',\n        );\n      }\n\n      // Get the block size\n      const nodeStatusInfo: INodeStatus =\n        await this.publicApiClient.getNodeStatus();\n      if (\n        data.contractDataBinary.length >\n        nodeStatusInfo.config.max_block_size / 2\n      ) {\n        console.warn(\n          'Bytecode size exceeded half of the maximum size of a block, operation will certainly be rejected',\n        );\n      }\n    };\n\n    return this.executeOperation(\n      contractData,\n      OperationTypeId.ExecuteSC,\n      false,\n      'Deploy smart contract operation bad response. No results array in json rpc response. Inspect smart contract',\n      preExecutionLogic,\n    );\n  }\n}\n"]}