{"version":3,"file":"time.js","sourceRoot":"","sources":["../../../src/utils/time.ts"],"names":[],"mappings":"AAAA,MAAM,UAAU,IAAI,CAAC,EAAU;IAC7B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3D,CAAC;AAED;;GAEG;AACH,MAAM,OAAO,OAAO;IAClB;;;;;OAKG;IACH,YAAY,UAAkB,EAAE,QAAoB;QAClD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEnC,MAAM,IAAI,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC,GAAG,EAAE;YACjC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;gBACrB,QAAQ,EAAE,CAAC;aACZ;QACH,CAAC,EAAE,UAAU,CAAC,CAAC;IACjB,CAAC;IACO,SAAS,CAAU;IACnB,QAAQ,CAAU;IAClB,WAAW,CAAgC;IAEnD;;OAEG;IACI,KAAK;QACV,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAC/B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;SACvB;IACH,CAAC;CACF;AAED;;;GAGG;AACH,MAAM,OAAO,QAAQ;IACnB;;;;;OAKG;IACH,YAAY,UAAkB,EAAE,QAAoB;QAClD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEnC,MAAM,IAAI,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC,GAAG,EAAE;YACnC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;gBACrB,QAAQ,EAAE,CAAC;aACZ;QACH,CAAC,EAAE,UAAU,CAAC,CAAC;IACjB,CAAC;IACO,SAAS,CAAU;IACnB,QAAQ,CAAU;IAClB,YAAY,CAAiB;IAErC;;OAEG;IACI,KAAK;QACV,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YACjC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;SACvB;IACH,CAAC;CACF;AAED;;;;;;;;;;GAUG;AACH,MAAM,CAAC,KAAK,UAAU,oBAAoB,CACxC,OAAmB,EACnB,SAAiB;IAEjB,MAAM,KAAK,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,CAC5C,UAAU,CACR,GAAG,EAAE,CACH,MAAM,CACJ,IAAI,KAAK,CACP,cAAc,SAAS,yCAAyC,CACjE,CACF,EACH,SAAS,CACV,CACF,CAAC;IACF,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAe,CAAC;AACtD,CAAC","sourcesContent":["export function wait(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * A class representing a timeout that triggers a callback function after a specified time interval.\n */\nexport class Timeout {\n  /**\n   * Constructs a new Timeout instance with the given timeout duration and callback function.\n   *\n   * @param timeoutMil - The timeout duration in milliseconds.\n   * @param callback - The function to be called when the timeout is triggered.\n   */\n  constructor(timeoutMil: number, callback: () => void) {\n    this.clear = this.clear.bind(this);\n\n    const that = this;\n    this.isCleared = false;\n    this.isCalled = false;\n    this.timeoutHook = setTimeout(() => {\n      if (!that.isCleared) {\n        this.isCalled = true;\n        callback();\n      }\n    }, timeoutMil);\n  }\n  private isCleared: boolean;\n  private isCalled: boolean;\n  private timeoutHook: ReturnType<typeof setTimeout>;\n\n  /**\n   * Clears the timeout so that the callback function is not called.\n   */\n  public clear(): void {\n    if (!this.isCleared) {\n      clearTimeout(this.timeoutHook);\n      this.isCleared = true;\n    }\n  }\n}\n\n/**\n * A class representing an interval that triggers a callback function repeatedly\n * at a specified time interval.\n */\nexport class Interval {\n  /**\n   * Constructs a new Interval instance with the given interval duration and callback function.\n   *\n   * @param timeoutMil - The interval duration in milliseconds.\n   * @param callback - The function to be called when the interval is triggered.\n   */\n  constructor(timeoutMil: number, callback: () => void) {\n    this.clear = this.clear.bind(this);\n\n    const that = this;\n    this.isCleared = false;\n    this.isCalled = false;\n    this.intervalHook = setInterval(() => {\n      if (!that.isCleared) {\n        this.isCalled = true;\n        callback();\n      }\n    }, timeoutMil);\n  }\n  private isCleared: boolean;\n  private isCalled: boolean;\n  private intervalHook: NodeJS.Timeout;\n\n  /**\n   * Clears the interval so that the callback function is not called anymore.\n   */\n  public clear(): void {\n    if (!this.isCleared) {\n      clearInterval(this.intervalHook);\n      this.isCleared = true;\n    }\n  }\n}\n\n/**\n * Returns a promise that resolves after the specified time interval and throws an error if the\n * specified promise does not resolve before the timeout interval.\n *\n * @param promise - The promise to be resolved.\n * @param timeoutMs - The time interval in milliseconds.\n *\n * @throws if the specified promise does not resolve before the timeout interval.\n *\n * @returns A promise that resolves after the specified time interval.\n */\nexport async function withTimeoutRejection<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n): Promise<T> {\n  const sleep = new Promise((resolve, reject) =>\n    setTimeout(\n      () =>\n        reject(\n          new Error(\n            `Timeout of ${timeoutMs} has passed and promise did not resolve`,\n          ),\n        ),\n      timeoutMs,\n    ),\n  );\n  return Promise.race([promise, sleep]) as Promise<T>;\n}\n"]}